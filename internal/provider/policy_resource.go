// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/conductorone/terraform-provider-conductorone/internal/provider/types"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk"
	"github.com/conductorone/terraform-provider-conductorone/internal/validators"
	speakeasy_objectvalidators "github.com/conductorone/terraform-provider-conductorone/internal/validators/objectvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &PolicyResource{}
var _ resource.ResourceWithImportState = &PolicyResource{}

func NewPolicyResource() resource.Resource {
	return &PolicyResource{}
}

// PolicyResource defines the resource implementation.
type PolicyResource struct {
	client *sdk.ConductoroneAPI
}

// PolicyResourceModel describes the resource data model.
type PolicyResourceModel struct {
	CreatedAt                types.String                   `tfsdk:"created_at"`
	DeletedAt                types.String                   `tfsdk:"-"`
	Description              types.String                   `tfsdk:"description"`
	DisplayName              types.String                   `tfsdk:"display_name"`
	ID                       types.String                   `tfsdk:"id"`
	PolicySteps              map[string]tfTypes.PolicySteps `tfsdk:"policy_steps"`
	PolicyType               types.String                   `tfsdk:"policy_type"`
	PostActions              []tfTypes.PolicyPostActions    `tfsdk:"post_actions"`
	ReassignTasksToDelegates types.Bool                     `tfsdk:"reassign_tasks_to_delegates"`
	Rules                    []tfTypes.Rule                 `tfsdk:"rules"`
	SystemBuiltin            types.Bool                     `tfsdk:"system_builtin"`
	UpdatedAt                types.String                   `tfsdk:"updated_at"`
}

func (r *PolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_policy"
}

func (r *PolicyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Policy Resource",
		Attributes: map[string]schema.Attribute{
			"created_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The description of the new policy.`,
			},
			"display_name": schema.StringAttribute{
				Required:    true,
				Description: `The display name of the new policy.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of the Policy.`,
			},
			"policy_steps": schema.MapNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"steps": schema.ListNestedAttribute{
							Computed: true,
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
								Attributes: map[string]schema.Attribute{
									"accept": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"accept_message": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `An optional message to include in the comments when a task is automatically accepted.`,
											},
										},
										Description: `This policy step indicates that a ticket should have an approved outcome. This is a terminal approval state and is used to explicitly define the end of approval steps.`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("approval"),
												path.MatchRelative().AtParent().AtName("provision"),
												path.MatchRelative().AtParent().AtName("reject"),
												path.MatchRelative().AtParent().AtName("wait"),
											}...),
										},
									},
									"approval": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"agent_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"agent_user_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The agent user ID to assign the task to.`,
													},
													"instructions": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Instructions for the agent.`,
													},
													"policy_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `The policyIds field.`,
													},
												},
												Description: `The agent to assign the task to.`,
											},
											"allow_reassignment": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Configuration to allow reassignment by reviewers during this step.`,
											},
											"allowed_reassignees": schema.ListAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Description: `List of users for whom this step can be reassigned.`,
											},
											"app_group_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval if the target user is a member of the group during this step.`,
													},
													"app_group_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The ID of the group specified for approval.`,
													},
													"app_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The ID of the app that contains the group specified for approval.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if the group is empty.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if fallback is enabled and the group is empty.`,
													},
												},
												Description: `The AppGroupApproval object provides the configuration for setting a group as the approvers of an approval policy step.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"app_owner_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration that allows a user to self approve if they are an app owner during this approval step.`,
													},
												},
												Description: `App owner approval provides the configuration for an approval step when the app owner is the target.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"assigned": schema.BoolAttribute{
												Computed:    true,
												Description: `A field indicating whether this step is assigned.`,
											},
											"entitlement_owner_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval if the target user is an entitlement owner during this step.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if the entitlement owner cannot be identified.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if fallback is enabled and the entitlement owner cannot be identified.`,
													},
												},
												Description: `The entitlement owner approval allows configuration of the approval step when the target approvers are the entitlement owners.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"expression_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval of if the user is specified and also the target of the ticket.`,
													},
													"assigned_user_ids": schema.ListAttribute{
														Computed:    true,
														ElementType: types.StringType,
														Description: `The assignedUserIds field.`,
													},
													"expressions": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Array of dynamic expressions to determine the approvers.  The first expression to return a non-empty list of users will be used.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if the expression does not return a valid list of users.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if and the expression does not return a valid list of users.`,
													},
												},
												Description: `The ExpressionApproval message.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"manager_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval if the target user is their own manager. This may occur if a service account has an identity user and manager specified as the same person.`,
													},
													"assigned_user_ids": schema.ListAttribute{
														Computed:    true,
														ElementType: types.StringType,
														Description: `The array of users determined to be the manager during processing time.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if no manager is found.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if fallback is enabled and no manager is found.`,
													},
												},
												Description: `The manager approval object provides configuration options for approval when the target of the approval is the manager of the user in the task.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"require_approval_reason": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Configuration to require a reason when approving this step.`,
											},
											"require_denial_reason": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Configuration to require a reason when denying this step.`,
											},
											"require_reassignment_reason": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Configuration to require a reason when reassigning this step.`,
											},
											"requires_step_up_provider_id": schema.StringAttribute{
												Computed: true,
												Optional: true,
												MarkdownDescription: `The ID of a step-up authentication provider that will be required for approvals on this step.` + "\n" +
													` If set, approvers must complete the step-up authentication flow before they can approve.`,
											},
											"resource_owner_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval if the target user is an resource owner during this step.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if the resource owner cannot be identified.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if fallback is enabled and the resource owner cannot be identified.`,
													},
												},
												Description: `The resource owner approval allows configuration of the approval step when the target approvers are the resource owners.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"self_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"assigned_user_ids": schema.ListAttribute{
														Computed:    true,
														ElementType: types.StringType,
														Description: `The array of users determined to be themselves during approval. This should only ever be one person, but is saved because it may change if the owner of an app user changes while the ticket is open.`,
													},
													"fallback": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow a fallback if the identity user of the target app user cannot be determined.`,
													},
													"fallback_user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Configuration to specific which users to fallback to if fallback is enabled and the identity user of the target app user cannot be determined.`,
													},
												},
												Description: `The self approval object describes the configuration of a policy step that needs to be approved by the target of the request.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"user_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"allow_self_approval": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Description: `Configuration to allow self approval of if the user is specified and also the target of the ticket.`,
													},
													"user_ids": schema.ListAttribute{
														Computed:    true,
														Optional:    true,
														ElementType: types.StringType,
														Description: `Array of users configured for approval.`,
													},
												},
												Description: `The user approval object describes the approval configuration of a policy step that needs to be approved by a specific list of users.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("webhook_approval"),
													}...),
												},
											},
											"webhook_approval": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"webhook_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The ID of the webhook to call for approval.`,
													},
												},
												Description: `The WebhookApproval message.`,
												Validators: []validator.Object{
													objectvalidator.ConflictsWith(path.Expressions{
														path.MatchRelative().AtParent().AtName("app_owner_approval"),
														path.MatchRelative().AtParent().AtName("app_group_approval"),
														path.MatchRelative().AtParent().AtName("entitlement_owner_approval"),
														path.MatchRelative().AtParent().AtName("expression_approval"),
														path.MatchRelative().AtParent().AtName("manager_approval"),
														path.MatchRelative().AtParent().AtName("resource_owner_approval"),
														path.MatchRelative().AtParent().AtName("self_approval"),
														path.MatchRelative().AtParent().AtName("user_approval"),
													}...),
												},
											},
										},
										MarkdownDescription: `The Approval message.` + "\n" +
											`` + "\n" +
											`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
											`  - users` + "\n" +
											`  - manager` + "\n" +
											`  - appOwners` + "\n" +
											`  - group` + "\n" +
											`  - self` + "\n" +
											`  - entitlementOwners` + "\n" +
											`  - expression` + "\n" +
											`  - webhook` + "\n" +
											`  - resourceOwners` + "\n" +
											`  - agent`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("accept"),
												path.MatchRelative().AtParent().AtName("provision"),
												path.MatchRelative().AtParent().AtName("reject"),
												path.MatchRelative().AtParent().AtName("wait"),
											}...),
										},
									},
									"provision": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"assigned": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Description: `A field indicating whether this step is assigned.`,
											},
											"provision_policy": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"connector_provision": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"account_provision": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"config": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																	},
																	"connector_id": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The connectorId field.`,
																	},
																	"do_not_save": schema.SingleNestedAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The DoNotSave message.`,
																	},
																	"save_to_vault": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"vault_ids": schema.ListAttribute{
																				Computed:    true,
																				Optional:    true,
																				ElementType: types.StringType,
																				Description: `The vaultIds field.`,
																			},
																		},
																		Description: `The SaveToVault message.`,
																	},
																	"schema_id": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The schemaId field.`,
																	},
																},
																MarkdownDescription: `The AccountProvision message.` + "\n" +
																	`` + "\n" +
																	`This message contains a oneof named storage_type. Only a single field of the following list may be set at a time:` + "\n" +
																	`  - saveToVault` + "\n" +
																	`  - doNotSave`,
															},
															"default_behavior": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"connector_id": schema.StringAttribute{
																		Computed: true,
																		Optional: true,
																		MarkdownDescription: `this checks if the entitlement is enabled by provisioning in a specific connector` + "\n" +
																			` this can happen automatically and doesn't need any extra info`,
																	},
																},
																Description: `The DefaultBehavior message.`,
															},
														},
														MarkdownDescription: `Indicates that a connector should perform the provisioning. This object has no fields.` + "\n" +
															`` + "\n" +
															`This message contains a oneof named provision_type. Only a single field of the following list may be set at a time:` + "\n" +
															`  - defaultBehavior` + "\n" +
															`  - account`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("delegated_provision"),
																path.MatchRelative().AtParent().AtName("external_ticket_provision"),
																path.MatchRelative().AtParent().AtName("manual_provision"),
																path.MatchRelative().AtParent().AtName("multi_step"),
																path.MatchRelative().AtParent().AtName("webhook_provision"),
															}...),
														},
													},
													"delegated_provision": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"app_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The AppID of the entitlement to delegate provisioning to.`,
															},
															"entitlement_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The ID of the entitlement we are delegating provisioning to.`,
															},
														},
														Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("connector_provision"),
																path.MatchRelative().AtParent().AtName("external_ticket_provision"),
																path.MatchRelative().AtParent().AtName("manual_provision"),
																path.MatchRelative().AtParent().AtName("multi_step"),
																path.MatchRelative().AtParent().AtName("webhook_provision"),
															}...),
														},
													},
													"external_ticket_provision": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"app_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The appId field.`,
															},
															"connector_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The connectorId field.`,
															},
															"external_ticket_provisioner_config_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The externalTicketProvisionerConfigId field.`,
															},
															"instructions": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
															},
														},
														Description: `This provision step indicates that we should check an external ticket to provision this entitlement`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("connector_provision"),
																path.MatchRelative().AtParent().AtName("delegated_provision"),
																path.MatchRelative().AtParent().AtName("manual_provision"),
																path.MatchRelative().AtParent().AtName("multi_step"),
																path.MatchRelative().AtParent().AtName("webhook_provision"),
															}...),
														},
													},
													"manual_provision": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"instructions": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
															},
															"user_ids": schema.ListAttribute{
																Computed:    true,
																Optional:    true,
																ElementType: types.StringType,
																Description: `An array of users that are required to provision during this step.`,
															},
														},
														Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("connector_provision"),
																path.MatchRelative().AtParent().AtName("delegated_provision"),
																path.MatchRelative().AtParent().AtName("external_ticket_provision"),
																path.MatchRelative().AtParent().AtName("multi_step"),
																path.MatchRelative().AtParent().AtName("webhook_provision"),
															}...),
														},
													},
													"multi_step": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `MultiStep indicates that this provision step has multiple steps to process. Parsed as JSON.`,
														Validators: []validator.String{
															stringvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("connector_provision"),
																path.MatchRelative().AtParent().AtName("delegated_provision"),
																path.MatchRelative().AtParent().AtName("external_ticket_provision"),
																path.MatchRelative().AtParent().AtName("manual_provision"),
																path.MatchRelative().AtParent().AtName("webhook_provision"),
															}...),
															validators.IsValidJSON(),
														},
													},
													"unconfigured_provision": schema.SingleNestedAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The UnconfiguredProvision message.`,
													},
													"webhook_provision": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"webhook_id": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The ID of the webhook to call for provisioning.`,
															},
														},
														Description: `This provision step indicates that a webhook should be called to provision this entitlement.`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("connector_provision"),
																path.MatchRelative().AtParent().AtName("delegated_provision"),
																path.MatchRelative().AtParent().AtName("external_ticket_provision"),
																path.MatchRelative().AtParent().AtName("manual_provision"),
																path.MatchRelative().AtParent().AtName("multi_step"),
															}...),
														},
													},
												},
												MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
													`` + "\n" +
													`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
													`  - connector` + "\n" +
													`  - manual` + "\n" +
													`  - delegated` + "\n" +
													`  - webhook` + "\n" +
													`  - multiStep` + "\n" +
													`  - externalTicket` + "\n" +
													`  - unconfigured`,
											},
											"provision_target": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"app_entitlement_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The app entitlement that should be provisioned.`,
													},
													"app_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The app in which the entitlement should be provisioned`,
													},
													"app_user_id": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The app user that should be provisioned. May be unset if the app user is unknown`,
													},
													"grant_duration": schema.StringAttribute{
														Computed: true,
														Optional: true,
													},
												},
												Description: `ProvisionTarget indicates the specific app, app entitlement, and if known, the app user and grant duration of this provision step`,
											},
										},
										Description: `The provision step references a provision policy for this step.`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("accept"),
												path.MatchRelative().AtParent().AtName("approval"),
												path.MatchRelative().AtParent().AtName("reject"),
												path.MatchRelative().AtParent().AtName("wait"),
											}...),
										},
									},
									"reject": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"reject_message": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `An optional message to include in the comments when a task is automatically rejected.`,
											},
										},
										Description: `This policy step indicates that a ticket should have a denied outcome. This is a terminal approval state and is used to explicitly define the end of approval steps.`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("accept"),
												path.MatchRelative().AtParent().AtName("approval"),
												path.MatchRelative().AtParent().AtName("provision"),
												path.MatchRelative().AtParent().AtName("wait"),
											}...),
										},
									},
									"wait": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"comment_on_first_wait": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `The comment to post on first failed check.`,
											},
											"comment_on_timeout": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `The comment to post if we timeout.`,
											},
											"name": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `The name of our condition to show on the task details page`,
											},
											"timeout_duration": schema.StringAttribute{
												Computed: true,
												Optional: true,
											},
											"wait_condition": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"condition": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `The condition that has to be true for this wait condition to continue.`,
													},
												},
												Description: `The WaitCondition message.`,
											},
										},
										MarkdownDescription: `Define a Wait step for a policy to wait on a condition to be met.` + "\n" +
											`` + "\n" +
											`This message contains a oneof named until. Only a single field of the following list may be set at a time:` + "\n" +
											`  - condition`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("accept"),
												path.MatchRelative().AtParent().AtName("approval"),
												path.MatchRelative().AtParent().AtName("provision"),
												path.MatchRelative().AtParent().AtName("reject"),
											}...),
										},
									},
								},
							},
							Description: `An array of policy steps indicating the processing flow of a policy. These steps are oneOfs, and only one property may be set for each array index at a time.`,
						},
					},
				},
				Description: `The map of policy type to policy steps. The key is the stringified version of the enum. See other policies for examples.`,
			},
			"policy_type": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The enum of the policy type. must be one of ["POLICY_TYPE_UNSPECIFIED", "POLICY_TYPE_GRANT", "POLICY_TYPE_REVOKE", "POLICY_TYPE_CERTIFY", "POLICY_TYPE_ACCESS_REQUEST", "POLICY_TYPE_PROVISION"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"POLICY_TYPE_UNSPECIFIED",
						"POLICY_TYPE_GRANT",
						"POLICY_TYPE_REVOKE",
						"POLICY_TYPE_CERTIFY",
						"POLICY_TYPE_ACCESS_REQUEST",
						"POLICY_TYPE_PROVISION",
					),
				},
			},
			"post_actions": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"certify_remediate_immediately": schema.BoolAttribute{
							Computed: true,
							Optional: true,
							MarkdownDescription: `ONLY valid when used in a CERTIFY Ticket Type:` + "\n" +
								` Causes any deprovision or change in a grant to be applied when Certify Ticket is closed.` + "\n" +
								`This field is part of the ` + "`" + `action` + "`" + ` oneof.` + "\n" +
								`See the documentation for ` + "`" + `c1.api.policy.v1.PolicyPostActions` + "`" + ` for more details.`,
						},
					},
				},
				Description: `Actions to occur after a policy finishes. As of now this is only valid on a certify policy to remediate a denied certification immediately.`,
			},
			"reassign_tasks_to_delegates": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Allows reassigning tasks to delegates.`,
			},
			"rules": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"condition": schema.StringAttribute{
							Computed:    true,
							Optional:    true,
							Description: `The condition field.`,
						},
						"policy_key": schema.StringAttribute{
							Computed:    true,
							Optional:    true,
							Description: `This is a reference to a list of policy steps from ` + "`" + `policy_steps` + "`" + ``,
						},
					},
				},
				Description: `The rules field.`,
			},
			"system_builtin": schema.BoolAttribute{
				Computed:    true,
				Description: `Whether this policy is a builtin system policy. Builtin system policies cannot be edited.`,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
		},
	}
}

func (r *PolicyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.ConductoroneAPI)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.ConductoroneAPI, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *PolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *PolicyResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToSharedCreatePolicyRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Policies.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.CreatePolicyResponse != nil && res.CreatePolicyResponse.Policy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedPolicy(ctx, res.CreatePolicyResponse.Policy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *PolicyResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIPolicyV1PoliciesGetRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Policies.Get(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.GetPolicyResponse != nil && res.GetPolicyResponse.Policy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedPolicy(ctx, res.GetPolicyResponse.Policy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if !data.DeletedAt.IsNull() {
		resp.State.RemoveResource(ctx)
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *PolicyResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIPolicyV1PoliciesUpdateRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Policies.Update(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.UpdatePolicyResponse != nil && res.UpdatePolicyResponse.Policy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedPolicy(ctx, res.UpdatePolicyResponse.Policy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsC1APIPolicyV1PoliciesGetRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Policies.Get(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.GetPolicyResponse != nil && res1.GetPolicyResponse.Policy != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedPolicy(ctx, res1.GetPolicyResponse.Policy)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *PolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *PolicyResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIPolicyV1PoliciesDeleteRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Policies.Delete(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *PolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
