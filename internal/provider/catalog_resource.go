// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/ConductorOne/terraform-provider-conductorone/internal/sdk"

	"github.com/ConductorOne/terraform-provider-conductorone/internal/sdk/pkg/models/operations"
	"github.com/ConductorOne/terraform-provider-conductorone/internal/sdk/pkg/models/shared"
	"github.com/ConductorOne/terraform-provider-conductorone/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &CatalogResource{}
var _ resource.ResourceWithImportState = &CatalogResource{}

func NewCatalogResource() resource.Resource {
	return &CatalogResource{}
}

// CatalogResource defines the resource implementation.
type CatalogResource struct {
	client *sdk.ConductoroneSDKTerraform
}

// CatalogResourceModel describes the resource data model.
type CatalogResourceModel struct {
	AccessEntitlements       []AppEntitlement                                     `tfsdk:"access_entitlements"`
	AccessEntitlementsPath   types.String                                         `tfsdk:"access_entitlements_path"`
	AppIds                   []types.String                                       `tfsdk:"app_ids"`
	AppPaths                 types.String                                         `tfsdk:"app_paths"`
	CreatedAt                types.String                                         `tfsdk:"created_at"`
	CreatedByUserID          types.String                                         `tfsdk:"created_by_user_id"`
	CreatedByUserPath        types.String                                         `tfsdk:"created_by_user_path"`
	DeletedAt                types.String                                         `tfsdk:"deleted_at"`
	Description              types.String                                         `tfsdk:"description"`
	DisplayName              types.String                                         `tfsdk:"display_name"`
	Expanded                 []RequestCatalogManagementServiceGetResponseExpanded `tfsdk:"expanded"`
	ID                       types.String                                         `tfsdk:"id"`
	Published                types.Bool                                           `tfsdk:"published"`
	RequestCatalogExpandMask *RequestCatalogExpandMask                            `tfsdk:"request_catalog_expand_mask"`
	UpdatedAt                types.String                                         `tfsdk:"updated_at"`
	VisibleToEveryone        types.Bool                                           `tfsdk:"visible_to_everyone"`
}

func (r *CatalogResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_catalog"
}

func (r *CatalogResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Catalog Resource",

		Attributes: map[string]schema.Attribute{
			"access_entitlements": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alias": schema.StringAttribute{
							Computed:    true,
							Description: `The alias of the app entitlement used by Cone. Also exact-match queryable.`,
						},
						"app_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the app that is associated with the app entitlement.`,
						},
						"app_resource_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the app resource that is associated with the app entitlement`,
						},
						"app_resource_type_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the app resource type that is associated with the app entitlement`,
						},
						"certify_policy_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the policy that will be used for certify tickets related to the app entitlement.`,
						},
						"compliance_framework_value_ids": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
							Description: `The IDs of different compliance frameworks associated with this app entitlement ex (SOX, HIPAA, PCI, etc.)`,
						},
						"created_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"deleted_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"description": schema.StringAttribute{
							Computed:    true,
							Description: `The description of the app entitlement.`,
						},
						"display_name": schema.StringAttribute{
							Computed:    true,
							Description: `The display name of the app entitlement.`,
						},
						"duration_grant": schema.StringAttribute{
							Computed: true,
						},
						"duration_unset": schema.SingleNestedAttribute{
							Computed:   true,
							Attributes: map[string]schema.Attribute{},
						},
						"emergency_grant_enabled": schema.BoolAttribute{
							Computed:    true,
							Description: `This enables tasks to be created in an emergency and use a selected emergency access policy.`,
						},
						"emergency_grant_policy_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the policy that will be used for emergency access grant tasks.`,
						},
						"grant_count": schema.StringAttribute{
							Computed:    true,
							Description: `The amount of grants open for this entitlement`,
						},
						"grant_policy_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the policy that will be used for grant tickets related to the app entitlement.`,
						},
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `The unique ID for the App Entitlement.`,
						},
						"provision_policy": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"connector_provision": schema.SingleNestedAttribute{
									Computed:    true,
									Attributes:  map[string]schema.Attribute{},
									Description: `Indicates that a connector should perform the provisioning. This object has no fields.`,
								},
								"delegated_provision": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The AppID of the entitlement to delegate provisioning to.`,
										},
										"entitlement_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the entitlement we are delegating provisioning to.`,
										},
										"implicit": schema.BoolAttribute{
											Computed:    true,
											Description: `If true, a binding will be automatically created from the entitlement of the parent app.`,
										},
									},
									Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
								},
								"manual_provision": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"instructions": schema.StringAttribute{
											Computed:    true,
											Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
										},
										"user_ids": schema.ListAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `An array of users that are required to provision during this step.`,
										},
									},
									Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
								},
							},
							MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
								`` + "\n" +
								`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
								`  - connector` + "\n" +
								`  - manual` + "\n" +
								`  - delegated` + "\n" +
								``,
						},
						"revoke_policy_id": schema.StringAttribute{
							Computed:    true,
							Description: `The ID of the policy that will be used for revoke tickets related to the app entitlement`,
						},
						"risk_level_value_id": schema.StringAttribute{
							Computed:    true,
							Description: `The riskLevelValueId field.`,
						},
						"slug": schema.StringAttribute{
							Computed:    true,
							Description: `The slug is displayed as an oval next to the name in the frontend of C1, it tells you what permission the entitlement grants. See https://www.conductorone.com/docs/product/manage-access/entitlements/`,
						},
						"system_builtin": schema.BoolAttribute{
							Computed:    true,
							Description: `This field indicates if this is a system builtin entitlement.`,
						},
						"updated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"user_edited_mask": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Description: `An array of app entitlements that, if the user has, can view the contents of this catalog.`,
			},
			"access_entitlements_path": schema.StringAttribute{
				Computed:    true,
				Description: `JSONPATH expression indicating the location of the access entitlement objects, that the request catalog allows users to request, in the array.`,
			},
			"app_ids": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `The Apps contained in this request catalog.`,
			},
			"app_paths": schema.StringAttribute{
				Computed:    true,
				Description: `JSONPATH expression indicating the location of the App object in the array.`,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"created_by_user_id": schema.StringAttribute{
				Computed:    true,
				Description: `The id of the user this request catalog was created by.`,
			},
			"created_by_user_path": schema.StringAttribute{
				Computed:    true,
				Description: `JSONPATH expression indicating the location of the User object, that created the request catalog, in the array.`,
			},
			"deleted_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The description of the new request catalog.`,
			},
			"display_name": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The display name of the new request catalog.`,
			},
			"expanded": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"at_type": schema.StringAttribute{
							Computed:    true,
							Description: `The type of the serialized message.`,
						},
						"additional_properties": schema.StringAttribute{
							Computed:    true,
							Description: `Parsed as JSON.`,
							Validators: []validator.String{
								validators.IsValidJSON(),
							},
						},
					},
				},
				Description: `List of serialized related objects.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The id of the request catalog.`,
			},
			"published": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether or not the new catalog should be created as published.`,
			},
			"request_catalog_expand_mask": schema.SingleNestedAttribute{
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"paths": schema.ListAttribute{
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplace(),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `An array of paths to be expanded in the response. May be any combination of "*", "created_by_user_id", "app_ids", and "access_entitlements".`,
					},
				},
				Description: `The RequestCatalogExpandMask includes the paths in the catalog view to expand in the return value of this call.`,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"visible_to_everyone": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Whether or not the new catalog is visible to everyone by default.`,
			},
		},
	}
}

func (r *CatalogResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.ConductoroneSDKTerraform)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.ConductoroneSDKTerraform, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *CatalogResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *CatalogResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := data.ToCreateSDKType()
	res, err := r.client.RequestCatalogManagement.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.RequestCatalogManagementServiceGetResponse == nil || res.RequestCatalogManagementServiceGetResponse.RequestCatalogView == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromCreateResponse(res.RequestCatalogManagementServiceGetResponse.RequestCatalogView.RequestCatalog)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CatalogResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *CatalogResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	id := data.ID.ValueString()
	request := operations.C1APIRequestcatalogV1RequestCatalogManagementServiceGetRequest{
		ID: id,
	}
	res, err := r.client.RequestCatalogManagement.Get(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.RequestCatalogManagementServiceGetResponse == nil || res.RequestCatalogManagementServiceGetResponse.RequestCatalogView == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromGetResponse(res.RequestCatalogManagementServiceGetResponse.RequestCatalogView.RequestCatalog)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CatalogResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *CatalogResourceModel
	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var requestCatalogManagementServiceUpdateRequest *shared.RequestCatalogManagementServiceUpdateRequest
	requestCatalog := data.ToUpdateSDKType()
	var requestCatalogExpandMask *shared.RequestCatalogExpandMask
	if data != nil {
		var paths []string = nil
		for _, pathsItem := range data.Paths {
			paths = append(paths, pathsItem.ValueString())
		}
		requestCatalogExpandMask = &shared.RequestCatalogExpandMask{
			Paths: paths,
		}
	}
	requestCatalogManagementServiceUpdateRequest = &shared.RequestCatalogManagementServiceUpdateRequest{
		RequestCatalog:           requestCatalog,
		RequestCatalogExpandMask: requestCatalogExpandMask,
	}
	id := data.ID.ValueString()
	request := operations.C1APIRequestcatalogV1RequestCatalogManagementServiceUpdateRequest{
		RequestCatalogManagementServiceUpdateRequest: requestCatalogManagementServiceUpdateRequest,
		ID: id,
	}
	res, err := r.client.RequestCatalogManagement.Update(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.RequestCatalogManagementServiceGetResponse == nil || res.RequestCatalogManagementServiceGetResponse.RequestCatalogView == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromUpdateResponse(res.RequestCatalogManagementServiceGetResponse.RequestCatalogView.RequestCatalog)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CatalogResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *CatalogResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	requestCatalogManagementServiceDeleteRequest := data.ToDeleteSDKType()
	id := data.ID.ValueString()
	request := operations.C1APIRequestcatalogV1RequestCatalogManagementServiceDeleteRequest{
		RequestCatalogManagementServiceDeleteRequest: requestCatalogManagementServiceDeleteRequest,
		ID: id,
	}
	res, err := r.client.RequestCatalogManagement.Delete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *CatalogResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
