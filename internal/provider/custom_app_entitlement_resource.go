// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	speakeasy_stringplanmodifier "github.com/conductorone/terraform-provider-conductorone/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/conductorone/terraform-provider-conductorone/internal/provider/types"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk/models/operations"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk/models/shared"
	"github.com/conductorone/terraform-provider-conductorone/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &CustomAppEntitlementResource{}
var _ resource.ResourceWithImportState = &CustomAppEntitlementResource{}

func NewCustomAppEntitlementResource() resource.Resource {
	return &CustomAppEntitlementResource{}
}

// CustomAppEntitlementResource defines the resource implementation.
type CustomAppEntitlementResource struct {
	client *sdk.ConductoroneAPI
}

// CustomAppEntitlementResourceModel describes the resource data model.
type CustomAppEntitlementResourceModel struct {
	Alias                          types.String                                      `tfsdk:"alias"`
	AppID                          types.String                                      `tfsdk:"app_id"`
	AppResourceID                  types.String                                      `tfsdk:"app_resource_id"`
	AppResourceTypeID              types.String                                      `tfsdk:"app_resource_type_id"`
	CertifyPolicyID                types.String                                      `tfsdk:"certify_policy_id"`
	ComplianceFrameworkValueIds    []types.String                                    `tfsdk:"compliance_framework_value_ids"`
	CreatedAt                      types.String                                      `tfsdk:"created_at"`
	DefaultValuesApplied           types.Bool                                        `tfsdk:"default_values_applied"`
	DeletedAt                      types.String                                      `tfsdk:"-"`
	DeprovisionerPolicy            *tfTypes.DeprovisionerPolicy                      `tfsdk:"deprovisioner_policy" tfPlanOnly:"true"`
	Description                    types.String                                      `tfsdk:"description"`
	DisplayName                    types.String                                      `tfsdk:"display_name"`
	DurationGrant                  types.String                                      `tfsdk:"duration_grant" tfPlanOnly:"true"`
	DurationUnset                  *tfTypes.CreateAppEntitlementRequestDurationUnset `tfsdk:"duration_unset" tfPlanOnly:"true"`
	EmergencyGrantEnabled          types.Bool                                        `tfsdk:"emergency_grant_enabled"`
	EmergencyGrantPolicyID         types.String                                      `tfsdk:"emergency_grant_policy_id"`
	Expanded                       []tfTypes.GetAppEntitlementResponseExpanded       `tfsdk:"expanded"`
	GrantCount                     types.String                                      `tfsdk:"grant_count"`
	GrantPolicyID                  types.String                                      `tfsdk:"grant_policy_id"`
	ID                             types.String                                      `tfsdk:"id"`
	IsAutomationEnabled            types.Bool                                        `tfsdk:"is_automation_enabled"`
	IsManuallyManaged              types.Bool                                        `tfsdk:"is_manually_managed"`
	MatchBatonID                   types.String                                      `tfsdk:"match_baton_id"`
	OverrideAccessRequestsDefaults types.Bool                                        `tfsdk:"override_access_requests_defaults"`
	ProvisionPolicy                *tfTypes.ProvisionPolicy                          `tfsdk:"provision_policy" tfPlanOnly:"true"`
	Purpose                        types.String                                      `tfsdk:"purpose"`
	RevokePolicyID                 types.String                                      `tfsdk:"revoke_policy_id"`
	RiskLevelValueID               types.String                                      `tfsdk:"risk_level_value_id"`
	Slug                           types.String                                      `tfsdk:"slug"`
	SourceConnectorIds             map[string]types.String                           `tfsdk:"source_connector_ids"`
	SystemBuiltin                  types.Bool                                        `tfsdk:"system_builtin"`
	UpdatedAt                      types.String                                      `tfsdk:"updated_at"`
}

func (r *CustomAppEntitlementResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_custom_app_entitlement"
}

func (r *CustomAppEntitlementResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "CustomAppEntitlement Resource",
		Attributes: map[string]schema.Attribute{
			"alias": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The alias field.`,
			},
			"app_id": schema.StringAttribute{
				Required: true,
			},
			"app_resource_id": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The appResourceId field. Requires replacement if changed.`,
			},
			"app_resource_type_id": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The appResourceTypeId field. Requires replacement if changed.`,
			},
			"certify_policy_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The certifyPolicyId field.`,
			},
			"compliance_framework_value_ids": schema.ListAttribute{
				Computed:    true,
				Optional:    true,
				ElementType: types.StringType,
				Description: `The complianceFrameworkValueIds field.`,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
			"default_values_applied": schema.BoolAttribute{
				Computed:    true,
				Description: `Flag to indicate if app-level access request defaults have been applied to the entitlement`,
			},
			"deprovisioner_policy": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"connector_provision": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"account_provision": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"config": schema.SingleNestedAttribute{
										Computed: true,
									},
									"connector_id": schema.StringAttribute{
										Computed:    true,
										Description: `The connectorId field.`,
									},
									"do_not_save": schema.SingleNestedAttribute{
										Computed:    true,
										Description: `The DoNotSave message.`,
									},
									"save_to_vault": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"vault_ids": schema.ListAttribute{
												Computed:    true,
												ElementType: types.StringType,
												Description: `The vaultIds field.`,
											},
										},
										Description: `The SaveToVault message.`,
									},
									"schema_id": schema.StringAttribute{
										Computed:    true,
										Description: `The schemaId field.`,
									},
								},
								MarkdownDescription: `The AccountProvision message.` + "\n" +
									`` + "\n" +
									`This message contains a oneof named storage_type. Only a single field of the following list may be set at a time:` + "\n" +
									`  - saveToVault` + "\n" +
									`  - doNotSave`,
							},
							"default_behavior": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"connector_id": schema.StringAttribute{
										Computed: true,
										MarkdownDescription: `this checks if the entitlement is enabled by provisioning in a specific connector` + "\n" +
											` this can happen automatically and doesn't need any extra info`,
									},
								},
								Description: `The DefaultBehavior message.`,
							},
						},
						MarkdownDescription: `Indicates that a connector should perform the provisioning. This object has no fields.` + "\n" +
							`` + "\n" +
							`This message contains a oneof named provision_type. Only a single field of the following list may be set at a time:` + "\n" +
							`  - defaultBehavior` + "\n" +
							`  - account`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"delegated_provision": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"app_id": schema.StringAttribute{
								Computed:    true,
								Description: `The AppID of the entitlement to delegate provisioning to.`,
							},
							"entitlement_id": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the entitlement we are delegating provisioning to.`,
							},
						},
						Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"external_ticket_provision": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"app_id": schema.StringAttribute{
								Computed:    true,
								Description: `The appId field.`,
							},
							"connector_id": schema.StringAttribute{
								Computed:    true,
								Description: `The connectorId field.`,
							},
							"external_ticket_provisioner_config_id": schema.StringAttribute{
								Computed:    true,
								Description: `The externalTicketProvisionerConfigId field.`,
							},
							"instructions": schema.StringAttribute{
								Computed:    true,
								Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
							},
						},
						Description: `This provision step indicates that we should check an external ticket to provision this entitlement`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"manual_provision": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"instructions": schema.StringAttribute{
								Computed:    true,
								Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
							},
							"user_ids": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `An array of users that are required to provision during this step.`,
							},
						},
						Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"multi_step": schema.StringAttribute{
						Computed:    true,
						Description: `MultiStep indicates that this provision step has multiple steps to process. Parsed as JSON.`,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
							validators.IsValidJSON(),
						},
					},
					"unconfigured_provision": schema.SingleNestedAttribute{
						Computed:    true,
						Description: `The UnconfiguredProvision message.`,
					},
					"webhook_provision": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"webhook_id": schema.StringAttribute{
								Computed:    true,
								Description: `The ID of the webhook to call for provisioning.`,
							},
						},
						Description: `This provision step indicates that a webhook should be called to provision this entitlement.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
							}...),
						},
					},
				},
				MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
					`` + "\n" +
					`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
					`  - connector` + "\n" +
					`  - manual` + "\n" +
					`  - delegated` + "\n" +
					`  - webhook` + "\n" +
					`  - multiStep` + "\n" +
					`  - externalTicket` + "\n" +
					`  - unconfigured`,
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The description field.`,
			},
			"display_name": schema.StringAttribute{
				Required:    true,
				Description: `The displayName field.`,
			},
			"duration_grant": schema.StringAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("duration_unset"),
					}...),
				},
			},
			"duration_unset": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("duration_grant"),
					}...),
				},
			},
			"emergency_grant_enabled": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The emergencyGrantEnabled field.`,
			},
			"emergency_grant_policy_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The emergencyGrantPolicyId field.`,
			},
			"expanded": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{},
				},
				Description: `The expanded field.`,
			},
			"grant_count": schema.StringAttribute{
				Computed:    true,
				Description: `The amount of grants open for this entitlement`,
			},
			"grant_policy_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The grantPolicyId field.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The unique ID for the App Entitlement.`,
			},
			"is_automation_enabled": schema.BoolAttribute{
				Computed:    true,
				Description: `Flag to indicate whether automation (for adding users to entitlement based on rules) has been enabled.`,
			},
			"is_manually_managed": schema.BoolAttribute{
				Computed:    true,
				Description: `Flag to indicate if the app entitlement is manually managed.`,
			},
			"match_baton_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `If supplied, it's implied that the entitlement is created before sync and needs to be merged with connector entitlement.`,
			},
			"override_access_requests_defaults": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The overrideAccessRequestsDefaults field.`,
			},
			"provision_policy": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"connector_provision": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"account_provision": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"config": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
									},
									"connector_id": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `The connectorId field.`,
									},
									"do_not_save": schema.SingleNestedAttribute{
										Computed:    true,
										Optional:    true,
										Description: `The DoNotSave message.`,
									},
									"save_to_vault": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"vault_ids": schema.ListAttribute{
												Computed:    true,
												Optional:    true,
												ElementType: types.StringType,
												Description: `The vaultIds field.`,
											},
										},
										Description: `The SaveToVault message.`,
									},
									"schema_id": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `The schemaId field.`,
									},
								},
								MarkdownDescription: `The AccountProvision message.` + "\n" +
									`` + "\n" +
									`This message contains a oneof named storage_type. Only a single field of the following list may be set at a time:` + "\n" +
									`  - saveToVault` + "\n" +
									`  - doNotSave`,
							},
							"default_behavior": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"connector_id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										MarkdownDescription: `this checks if the entitlement is enabled by provisioning in a specific connector` + "\n" +
											` this can happen automatically and doesn't need any extra info`,
									},
								},
								Description: `The DefaultBehavior message.`,
							},
						},
						MarkdownDescription: `Indicates that a connector should perform the provisioning. This object has no fields.` + "\n" +
							`` + "\n" +
							`This message contains a oneof named provision_type. Only a single field of the following list may be set at a time:` + "\n" +
							`  - defaultBehavior` + "\n" +
							`  - account`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"delegated_provision": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"app_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The AppID of the entitlement to delegate provisioning to.`,
							},
							"entitlement_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The ID of the entitlement we are delegating provisioning to.`,
							},
						},
						Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"external_ticket_provision": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"app_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The appId field.`,
							},
							"connector_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The connectorId field.`,
							},
							"external_ticket_provisioner_config_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The externalTicketProvisionerConfigId field.`,
							},
							"instructions": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
							},
						},
						Description: `This provision step indicates that we should check an external ticket to provision this entitlement`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"manual_provision": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"instructions": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
							},
							"user_ids": schema.ListAttribute{
								Computed:    true,
								Optional:    true,
								ElementType: types.StringType,
								Description: `An array of users that are required to provision during this step.`,
							},
						},
						Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
						},
					},
					"multi_step": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `MultiStep indicates that this provision step has multiple steps to process. Parsed as JSON.`,
						Validators: []validator.String{
							stringvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("webhook_provision"),
							}...),
							validators.IsValidJSON(),
						},
					},
					"unconfigured_provision": schema.SingleNestedAttribute{
						Computed:    true,
						Optional:    true,
						Description: `The UnconfiguredProvision message.`,
					},
					"webhook_provision": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"webhook_id": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `The ID of the webhook to call for provisioning.`,
							},
						},
						Description: `This provision step indicates that a webhook should be called to provision this entitlement.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("connector_provision"),
								path.MatchRelative().AtParent().AtName("delegated_provision"),
								path.MatchRelative().AtParent().AtName("external_ticket_provision"),
								path.MatchRelative().AtParent().AtName("manual_provision"),
								path.MatchRelative().AtParent().AtName("multi_step"),
							}...),
						},
					},
				},
				MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
					`` + "\n" +
					`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
					`  - connector` + "\n" +
					`  - manual` + "\n" +
					`  - delegated` + "\n" +
					`  - webhook` + "\n" +
					`  - multiStep` + "\n" +
					`  - externalTicket` + "\n" +
					`  - unconfigured`,
			},
			"purpose": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The purpose field. must be one of ["APP_ENTITLEMENT_PURPOSE_VALUE_UNSPECIFIED", "APP_ENTITLEMENT_PURPOSE_VALUE_ASSIGNMENT", "APP_ENTITLEMENT_PURPOSE_VALUE_PERMISSION"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"APP_ENTITLEMENT_PURPOSE_VALUE_UNSPECIFIED",
						"APP_ENTITLEMENT_PURPOSE_VALUE_ASSIGNMENT",
						"APP_ENTITLEMENT_PURPOSE_VALUE_PERMISSION",
					),
				},
			},
			"revoke_policy_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The revokePolicyId field.`,
			},
			"risk_level_value_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The riskLevelValueId field.`,
			},
			"slug": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `The slug field.`,
			},
			"source_connector_ids": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `Map to tell us which connector the entitlement came from.`,
			},
			"system_builtin": schema.BoolAttribute{
				Computed:    true,
				Description: `This field indicates if this is a system builtin entitlement.`,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
			},
		},
	}
}

func (r *CustomAppEntitlementResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.ConductoroneAPI)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.ConductoroneAPI, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *CustomAppEntitlementResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *CustomAppEntitlementResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	createAppEntitlementRequest := data.ToSharedCreateAppEntitlementRequest()
	request := operations.C1APIAppV1AppEntitlementsCreateRequest{
		AppID:                       appID,
		CreateAppEntitlementRequest: createAppEntitlementRequest,
	}
	res, err := r.client.AppEntitlements.Create(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.CreateAppEntitlementResponse != nil && res.CreateAppEntitlementResponse.AppEntitlementView != nil && res.CreateAppEntitlementResponse.AppEntitlementView.AppEntitlement != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppEntitlement(res.CreateAppEntitlementResponse.AppEntitlementView.AppEntitlement)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomAppEntitlementResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *CustomAppEntitlementResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	var id string
	id = data.ID.ValueString()

	request := operations.C1APIAppV1AppEntitlementsGetRequest{
		AppID: appID,
		ID:    id,
	}
	res, err := r.client.AppEntitlements.Get(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.GetAppEntitlementResponse != nil && res.GetAppEntitlementResponse.AppEntitlementView != nil && res.GetAppEntitlementResponse.AppEntitlementView.AppEntitlement != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppEntitlement(res.GetAppEntitlementResponse.AppEntitlementView.AppEntitlement)

	if !data.DeletedAt.IsNull() {
		resp.State.RemoveResource(ctx)
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomAppEntitlementResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *CustomAppEntitlementResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	var id string
	id = data.ID.ValueString()

	var updateAppEntitlementRequest *shared.UpdateAppEntitlementRequest
	appEntitlement := data.ToSharedAppEntitlementInput()
	overrideAccessRequestsDefaults := new(bool)
	if !data.OverrideAccessRequestsDefaults.IsUnknown() && !data.OverrideAccessRequestsDefaults.IsNull() {
		*overrideAccessRequestsDefaults = data.OverrideAccessRequestsDefaults.ValueBool()
	} else {
		overrideAccessRequestsDefaults = nil
	}
	updateAppEntitlementRequest = &shared.UpdateAppEntitlementRequest{
		AppEntitlement:                 appEntitlement,
		OverrideAccessRequestsDefaults: overrideAccessRequestsDefaults,
	}
	request := operations.C1APIAppV1AppEntitlementsUpdateRequest{
		AppID:                       appID,
		ID:                          id,
		UpdateAppEntitlementRequest: updateAppEntitlementRequest,
	}
	res, err := r.client.AppEntitlements.Update(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.UpdateAppEntitlementResponse != nil && res.UpdateAppEntitlementResponse.AppEntitlementView != nil && res.UpdateAppEntitlementResponse.AppEntitlementView.AppEntitlement != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppEntitlement(res.UpdateAppEntitlementResponse.AppEntitlementView.AppEntitlement)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	var appId1 string
	appId1 = data.AppID.ValueString()

	var id1 string
	id1 = data.ID.ValueString()

	request1 := operations.C1APIAppV1AppEntitlementsGetRequest{
		AppID: appId1,
		ID:    id1,
	}
	res1, err := r.client.AppEntitlements.Get(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.GetAppEntitlementResponse != nil && res1.GetAppEntitlementResponse.AppEntitlementView != nil && res1.GetAppEntitlementResponse.AppEntitlementView.AppEntitlement != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedAppEntitlement(res1.GetAppEntitlementResponse.AppEntitlementView.AppEntitlement)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CustomAppEntitlementResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *CustomAppEntitlementResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	var id string
	id = data.ID.ValueString()

	request := operations.C1APIAppV1AppEntitlementsDeleteRequest{
		AppID: appID,
		ID:    id,
	}
	res, err := r.client.AppEntitlements.Delete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *CustomAppEntitlementResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		AppID string `json:"app_id"`
		ID    string `json:"id"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The ID is not valid. It's expected to be a JSON object alike '{ "app_id": "",  "id": ""}': `+err.Error())
		return
	}

	if len(data.AppID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field app_id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("app_id"), data.AppID)...)
	if len(data.ID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field id is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), data.ID)...)

}
