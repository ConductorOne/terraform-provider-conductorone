// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/conductorone/terraform-provider-conductorone/internal/provider/types"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk/models/operations"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *RequestSchemaDataSourceModel) RefreshFromSharedForm(ctx context.Context, resp *shared.Form) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Description = types.StringPointerValue(resp.Description)
		if resp.FieldRelationships != nil {
			r.FieldRelationships = []tfTypes.FieldRelationship{}

			for _, fieldRelationshipsItem := range resp.FieldRelationships {
				var fieldRelationships tfTypes.FieldRelationship

				if fieldRelationshipsItem.AtLeastOne == nil {
					fieldRelationships.AtLeastOne = nil
				} else {
					fieldRelationships.AtLeastOne = &tfTypes.AtLeastOne{}
				}
				if fieldRelationshipsItem.FieldNames != nil {
					fieldRelationships.FieldNames = make([]types.String, 0, len(fieldRelationshipsItem.FieldNames))
					for _, v := range fieldRelationshipsItem.FieldNames {
						fieldRelationships.FieldNames = append(fieldRelationships.FieldNames, types.StringValue(v))
					}
				}
				if fieldRelationshipsItem.MutuallyExclusive == nil {
					fieldRelationships.MutuallyExclusive = nil
				} else {
					fieldRelationships.MutuallyExclusive = &tfTypes.MutuallyExclusive{}
				}
				if fieldRelationshipsItem.RequiredTogether == nil {
					fieldRelationships.RequiredTogether = nil
				} else {
					fieldRelationships.RequiredTogether = &tfTypes.RequiredTogether{}
				}

				r.FieldRelationships = append(r.FieldRelationships, fieldRelationships)
			}
		}
		if resp.Fields != nil {
			r.Fields = []tfTypes.Field{}

			for _, fieldsItem := range resp.Fields {
				var fields tfTypes.Field

				if fieldsItem.BoolField == nil {
					fields.BoolField = nil
				} else {
					fields.BoolField = &tfTypes.BoolField{}
					if fieldsItem.BoolField.BoolRules == nil {
						fields.BoolField.BoolRules = nil
					} else {
						fields.BoolField.BoolRules = &tfTypes.BoolRules{}
						fields.BoolField.BoolRules.Const = types.BoolPointerValue(fieldsItem.BoolField.BoolRules.Const)
					}
					if fieldsItem.BoolField.CheckboxField == nil {
						fields.BoolField.CheckboxField = nil
					} else {
						fields.BoolField.CheckboxField = &tfTypes.CheckboxField{}
					}
					fields.BoolField.DefaultValue = types.BoolPointerValue(fieldsItem.BoolField.DefaultValue)
				}
				fields.Description = types.StringPointerValue(fieldsItem.Description)
				fields.DisplayName = types.StringPointerValue(fieldsItem.DisplayName)
				if fieldsItem.FileField == nil {
					fields.FileField = nil
				} else {
					fields.FileField = &tfTypes.FileField{}
					if fieldsItem.FileField.AcceptedFileTypes != nil {
						fields.FileField.AcceptedFileTypes = make([]types.String, 0, len(fieldsItem.FileField.AcceptedFileTypes))
						for _, v := range fieldsItem.FileField.AcceptedFileTypes {
							fields.FileField.AcceptedFileTypes = append(fields.FileField.AcceptedFileTypes, types.StringValue(v))
						}
					}
					if fieldsItem.FileField.FileInputField == nil {
						fields.FileField.FileInputField = nil
					} else {
						fields.FileField.FileInputField = &tfTypes.FileInputField{}
					}
					fields.FileField.MaxFileSize = types.StringPointerValue(fieldsItem.FileField.MaxFileSize)
				}
				if fieldsItem.Int64Field == nil {
					fields.Int64Field = nil
				} else {
					fields.Int64Field = &tfTypes.Int64Field{}
					fields.Int64Field.DefaultValue = types.StringPointerValue(fieldsItem.Int64Field.DefaultValue)
					if fieldsItem.Int64Field.Int64Rules == nil {
						fields.Int64Field.Int64Rules = nil
					} else {
						fields.Int64Field.Int64Rules = &tfTypes.Int64Rules{}
						fields.Int64Field.Int64Rules.Const = types.StringPointerValue(fieldsItem.Int64Field.Int64Rules.Const)
						fields.Int64Field.Int64Rules.Gt = types.StringPointerValue(fieldsItem.Int64Field.Int64Rules.Gt)
						fields.Int64Field.Int64Rules.Gte = types.StringPointerValue(fieldsItem.Int64Field.Int64Rules.Gte)
						fields.Int64Field.Int64Rules.IgnoreEmpty = types.BoolPointerValue(fieldsItem.Int64Field.Int64Rules.IgnoreEmpty)
						if fieldsItem.Int64Field.Int64Rules.In != nil {
							fields.Int64Field.Int64Rules.In = make([]types.String, 0, len(fieldsItem.Int64Field.Int64Rules.In))
							for _, v := range fieldsItem.Int64Field.Int64Rules.In {
								fields.Int64Field.Int64Rules.In = append(fields.Int64Field.Int64Rules.In, types.StringValue(v))
							}
						}
						fields.Int64Field.Int64Rules.Lt = types.StringPointerValue(fieldsItem.Int64Field.Int64Rules.Lt)
						fields.Int64Field.Int64Rules.Lte = types.StringPointerValue(fieldsItem.Int64Field.Int64Rules.Lte)
						if fieldsItem.Int64Field.Int64Rules.NotIn != nil {
							fields.Int64Field.Int64Rules.NotIn = make([]types.String, 0, len(fieldsItem.Int64Field.Int64Rules.NotIn))
							for _, v := range fieldsItem.Int64Field.Int64Rules.NotIn {
								fields.Int64Field.Int64Rules.NotIn = append(fields.Int64Field.Int64Rules.NotIn, types.StringValue(v))
							}
						}
					}
					if fieldsItem.Int64Field.NumberField == nil {
						fields.Int64Field.NumberField = nil
					} else {
						fields.Int64Field.NumberField = &tfTypes.NumberField{}
						fields.Int64Field.NumberField.MaxValue = types.StringPointerValue(fieldsItem.Int64Field.NumberField.MaxValue)
						fields.Int64Field.NumberField.MinValue = types.StringPointerValue(fieldsItem.Int64Field.NumberField.MinValue)
						fields.Int64Field.NumberField.Step = types.StringPointerValue(fieldsItem.Int64Field.NumberField.Step)
					}
					fields.Int64Field.Placeholder = types.StringPointerValue(fieldsItem.Int64Field.Placeholder)
				}
				fields.Name = types.StringPointerValue(fieldsItem.Name)
				if fieldsItem.StringField == nil {
					fields.StringField = nil
				} else {
					fields.StringField = &tfTypes.StringField{}
					fields.StringField.DefaultValue = types.StringPointerValue(fieldsItem.StringField.DefaultValue)
					if fieldsItem.StringField.PasswordField == nil {
						fields.StringField.PasswordField = nil
					} else {
						fields.StringField.PasswordField = &tfTypes.PasswordField{}
					}
					fields.StringField.Placeholder = types.StringPointerValue(fieldsItem.StringField.Placeholder)
					if fieldsItem.StringField.SelectField == nil {
						fields.StringField.SelectField = nil
					} else {
						fields.StringField.SelectField = &tfTypes.SelectField{}
						if fieldsItem.StringField.SelectField.Options != nil {
							fields.StringField.SelectField.Options = []tfTypes.SelectOption{}

							for _, optionsVarItem := range fieldsItem.StringField.SelectField.Options {
								var optionsVar tfTypes.SelectOption

								optionsVar.DisplayName = types.StringPointerValue(optionsVarItem.DisplayName)
								optionsVar.Value = types.StringPointerValue(optionsVarItem.Value)

								fields.StringField.SelectField.Options = append(fields.StringField.SelectField.Options, optionsVar)
							}
						}
					}
					if fieldsItem.StringField.StringRules == nil {
						fields.StringField.StringRules = nil
					} else {
						fields.StringField.StringRules = &tfTypes.StringRules{}
						fields.StringField.StringRules.Address = types.BoolPointerValue(fieldsItem.StringField.StringRules.Address)
						fields.StringField.StringRules.Const = types.StringPointerValue(fieldsItem.StringField.StringRules.Const)
						fields.StringField.StringRules.Contains = types.StringPointerValue(fieldsItem.StringField.StringRules.Contains)
						fields.StringField.StringRules.Email = types.BoolPointerValue(fieldsItem.StringField.StringRules.Email)
						fields.StringField.StringRules.Hostname = types.BoolPointerValue(fieldsItem.StringField.StringRules.Hostname)
						fields.StringField.StringRules.IgnoreEmpty = types.BoolPointerValue(fieldsItem.StringField.StringRules.IgnoreEmpty)
						if fieldsItem.StringField.StringRules.In != nil {
							fields.StringField.StringRules.In = make([]types.String, 0, len(fieldsItem.StringField.StringRules.In))
							for _, v := range fieldsItem.StringField.StringRules.In {
								fields.StringField.StringRules.In = append(fields.StringField.StringRules.In, types.StringValue(v))
							}
						}
						fields.StringField.StringRules.IP = types.BoolPointerValue(fieldsItem.StringField.StringRules.IP)
						fields.StringField.StringRules.Ipv4 = types.BoolPointerValue(fieldsItem.StringField.StringRules.Ipv4)
						fields.StringField.StringRules.Ipv6 = types.BoolPointerValue(fieldsItem.StringField.StringRules.Ipv6)
						fields.StringField.StringRules.LenBytes = types.StringPointerValue(fieldsItem.StringField.StringRules.LenBytes)
						fields.StringField.StringRules.Length = types.StringPointerValue(fieldsItem.StringField.StringRules.Length)
						fields.StringField.StringRules.MaxBytes = types.StringPointerValue(fieldsItem.StringField.StringRules.MaxBytes)
						fields.StringField.StringRules.MaxLen = types.StringPointerValue(fieldsItem.StringField.StringRules.MaxLen)
						fields.StringField.StringRules.MinBytes = types.StringPointerValue(fieldsItem.StringField.StringRules.MinBytes)
						fields.StringField.StringRules.MinLen = types.StringPointerValue(fieldsItem.StringField.StringRules.MinLen)
						fields.StringField.StringRules.NotContains = types.StringPointerValue(fieldsItem.StringField.StringRules.NotContains)
						if fieldsItem.StringField.StringRules.NotIn != nil {
							fields.StringField.StringRules.NotIn = make([]types.String, 0, len(fieldsItem.StringField.StringRules.NotIn))
							for _, v := range fieldsItem.StringField.StringRules.NotIn {
								fields.StringField.StringRules.NotIn = append(fields.StringField.StringRules.NotIn, types.StringValue(v))
							}
						}
						fields.StringField.StringRules.Pattern = types.StringPointerValue(fieldsItem.StringField.StringRules.Pattern)
						fields.StringField.StringRules.Prefix = types.StringPointerValue(fieldsItem.StringField.StringRules.Prefix)
						fields.StringField.StringRules.Strict = types.BoolPointerValue(fieldsItem.StringField.StringRules.Strict)
						fields.StringField.StringRules.Suffix = types.StringPointerValue(fieldsItem.StringField.StringRules.Suffix)
						fields.StringField.StringRules.URI = types.BoolPointerValue(fieldsItem.StringField.StringRules.URI)
						fields.StringField.StringRules.URIRef = types.BoolPointerValue(fieldsItem.StringField.StringRules.URIRef)
						fields.StringField.StringRules.UUID = types.BoolPointerValue(fieldsItem.StringField.StringRules.UUID)
						if fieldsItem.StringField.StringRules.WellKnownRegex != nil {
							fields.StringField.StringRules.WellKnownRegex = types.StringValue(string(*fieldsItem.StringField.StringRules.WellKnownRegex))
						} else {
							fields.StringField.StringRules.WellKnownRegex = types.StringNull()
						}
					}
					if fieldsItem.StringField.TextField == nil {
						fields.StringField.TextField = nil
					} else {
						fields.StringField.TextField = &tfTypes.TextField{}
						fields.StringField.TextField.Multiline = types.BoolPointerValue(fieldsItem.StringField.TextField.Multiline)
					}
				}

				r.Fields = append(r.Fields, fields)
			}
		}
		r.Name = types.StringPointerValue(resp.Name)
	}

	return diags
}

func (r *RequestSchemaDataSourceModel) ToOperationsC1APIRequestSchemaV1RequestSchemaServiceGetRequest(ctx context.Context) (*operations.C1APIRequestSchemaV1RequestSchemaServiceGetRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.C1APIRequestSchemaV1RequestSchemaServiceGetRequest{
		ID: id,
	}

	return &out, diags
}
