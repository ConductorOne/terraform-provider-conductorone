// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	speakeasy_stringplanmodifier "github.com/conductorone/terraform-provider-conductorone/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/conductorone/terraform-provider-conductorone/internal/provider/types"
	"github.com/conductorone/terraform-provider-conductorone/internal/sdk"
	"github.com/conductorone/terraform-provider-conductorone/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &AccessProfileRequestableEntriesResource{}
var _ resource.ResourceWithImportState = &AccessProfileRequestableEntriesResource{}

func NewAccessProfileRequestableEntriesResource() resource.Resource {
	return &AccessProfileRequestableEntriesResource{}
}

// AccessProfileRequestableEntriesResource defines the resource implementation.
type AccessProfileRequestableEntriesResource struct {
	client *sdk.ConductoroneAPI
}

// AccessProfileRequestableEntriesResourceModel describes the resource data model.
type AccessProfileRequestableEntriesResourceModel struct {
	AppEntitlements []tfTypes.AppEntitlementRef                                                         `tfsdk:"app_entitlements"`
	CatalogID       types.String                                                                        `tfsdk:"catalog_id"`
	CreateRequests  types.Bool                                                                          `tfsdk:"create_requests"`
	Expanded        []tfTypes.RequestCatalogManagementServiceListEntitlementsPerCatalogResponseExpanded `tfsdk:"expanded"`
	List            []tfTypes.AppEntitlementView                                                        `tfsdk:"list"`
	NextPageToken   types.String                                                                        `tfsdk:"next_page_token"`
}

func (r *AccessProfileRequestableEntriesResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_access_profile_requestable_entries"
}

func (r *AccessProfileRequestableEntriesResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "AccessProfileRequestableEntries Resource",
		Attributes: map[string]schema.Attribute{
			"app_entitlements": schema.ListNestedAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplaceIfConfigured(),
				},
				NestedObject: schema.NestedAttributeObject{
					PlanModifiers: []planmodifier.Object{
						objectplanmodifier.RequiresReplaceIfConfigured(),
					},
					Attributes: map[string]schema.Attribute{
						"app_id": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The appId field. Requires replacement if changed.`,
						},
						"id": schema.StringAttribute{
							Optional: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Description: `The id field. Requires replacement if changed.`,
						},
					},
				},
				Description: `List of entitlements to add to the request catalog. Requires replacement if changed.`,
			},
			"catalog_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `Requires replacement if changed.`,
			},
			"create_requests": schema.BoolAttribute{
				Optional: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplaceIfConfigured(),
				},
				MarkdownDescription: `Whether or not to create requests for newly added entitlements for users in the catalog.` + "\n" +
					` By default, this is false and no requests are created.` + "\n" +
					`Requires replacement if changed.`,
			},
			"expanded": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{},
				},
				Description: `List of serialized related objects.`,
			},
			"list": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"app_entitlement": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"alias": schema.StringAttribute{
									Computed:    true,
									Description: `The alias of the app entitlement used by Cone. Also exact-match queryable.`,
								},
								"app_id": schema.StringAttribute{
									Computed:    true,
									Description: `The ID of the app that is associated with the app entitlement.`,
								},
								"app_resource_id": schema.StringAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.String{
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The ID of the app resource that is associated with the app entitlement`,
								},
								"app_resource_type_id": schema.StringAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.String{
										speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
									},
									Description: `The ID of the app resource type that is associated with the app entitlement`,
								},
								"certify_policy_id": schema.StringAttribute{
									Computed:    true,
									Description: `The ID of the policy that will be used for certify tickets related to the app entitlement.`,
								},
								"compliance_framework_value_ids": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
									Description: `The IDs of different compliance frameworks associated with this app entitlement ex (SOX, HIPAA, PCI, etc.)`,
								},
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"default_values_applied": schema.BoolAttribute{
									Computed:    true,
									Description: `Flag to indicate if app-level access request defaults have been applied to the entitlement`,
								},
								"deprovisioner_policy": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"connector_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"account_provision": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"config": schema.SingleNestedAttribute{
															Computed: true,
														},
														"connector_id": schema.StringAttribute{
															Computed:    true,
															Description: `The connectorId field.`,
														},
														"do_not_save": schema.SingleNestedAttribute{
															Computed:    true,
															Description: `The DoNotSave message.`,
														},
														"save_to_vault": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"vault_ids": schema.ListAttribute{
																	Computed:    true,
																	ElementType: types.StringType,
																	Description: `The vaultIds field.`,
																},
															},
															Description: `The SaveToVault message.`,
														},
														"schema_id": schema.StringAttribute{
															Computed:    true,
															Description: `The schemaId field.`,
														},
													},
													MarkdownDescription: `The AccountProvision message.` + "\n" +
														`` + "\n" +
														`This message contains a oneof named storage_type. Only a single field of the following list may be set at a time:` + "\n" +
														`  - saveToVault` + "\n" +
														`  - doNotSave`,
												},
												"default_behavior": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"connector_id": schema.StringAttribute{
															Computed: true,
															MarkdownDescription: `this checks if the entitlement is enabled by provisioning in a specific connector` + "\n" +
																` this can happen automatically and doesn't need any extra info`,
														},
													},
													Description: `The DefaultBehavior message.`,
												},
											},
											MarkdownDescription: `Indicates that a connector should perform the provisioning. This object has no fields.` + "\n" +
												`` + "\n" +
												`This message contains a oneof named provision_type. Only a single field of the following list may be set at a time:` + "\n" +
												`  - defaultBehavior` + "\n" +
												`  - account`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"delegated_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed:    true,
													Description: `The AppID of the entitlement to delegate provisioning to.`,
												},
												"entitlement_id": schema.StringAttribute{
													Computed:    true,
													Description: `The ID of the entitlement we are delegating provisioning to.`,
												},
											},
											Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"external_ticket_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed:    true,
													Description: `The appId field.`,
												},
												"connector_id": schema.StringAttribute{
													Computed:    true,
													Description: `The connectorId field.`,
												},
												"external_ticket_provisioner_config_id": schema.StringAttribute{
													Computed:    true,
													Description: `The externalTicketProvisionerConfigId field.`,
												},
												"instructions": schema.StringAttribute{
													Computed:    true,
													Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
												},
											},
											Description: `This provision step indicates that we should check an external ticket to provision this entitlement`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"manual_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"instructions": schema.StringAttribute{
													Computed:    true,
													Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
												},
												"user_ids": schema.ListAttribute{
													Computed:    true,
													ElementType: types.StringType,
													Description: `An array of users that are required to provision during this step.`,
												},
											},
											Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"multi_step": schema.StringAttribute{
											Computed:    true,
											Description: `MultiStep indicates that this provision step has multiple steps to process. Parsed as JSON.`,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
												validators.IsValidJSON(),
											},
										},
										"unconfigured_provision": schema.SingleNestedAttribute{
											Computed:    true,
											Description: `The UnconfiguredProvision message.`,
										},
										"webhook_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"webhook_id": schema.StringAttribute{
													Computed:    true,
													Description: `The ID of the webhook to call for provisioning.`,
												},
											},
											Description: `This provision step indicates that a webhook should be called to provision this entitlement.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
												}...),
											},
										},
									},
									MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
										`` + "\n" +
										`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
										`  - connector` + "\n" +
										`  - manual` + "\n" +
										`  - delegated` + "\n" +
										`  - webhook` + "\n" +
										`  - multiStep` + "\n" +
										`  - externalTicket` + "\n" +
										`  - unconfigured`,
								},
								"description": schema.StringAttribute{
									Computed:    true,
									Description: `The description of the app entitlement.`,
								},
								"display_name": schema.StringAttribute{
									Computed:    true,
									Description: `The display name of the app entitlement.`,
								},
								"duration_grant": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("duration_unset"),
										}...),
									},
								},
								"duration_unset": schema.SingleNestedAttribute{
									Computed: true,
									Validators: []validator.Object{
										objectvalidator.ConflictsWith(path.Expressions{
											path.MatchRelative().AtParent().AtName("duration_grant"),
										}...),
									},
								},
								"emergency_grant_enabled": schema.BoolAttribute{
									Computed:    true,
									Description: `This enables tasks to be created in an emergency and use a selected emergency access policy.`,
								},
								"emergency_grant_policy_id": schema.StringAttribute{
									Computed:    true,
									Description: `The ID of the policy that will be used for emergency access grant tasks.`,
								},
								"grant_count": schema.StringAttribute{
									Computed:    true,
									Description: `The amount of grants open for this entitlement`,
								},
								"grant_policy_id": schema.StringAttribute{
									Computed:    true,
									Description: `The ID of the policy that will be used for grant tickets related to the app entitlement.`,
								},
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `The unique ID for the App Entitlement.`,
								},
								"is_automation_enabled": schema.BoolAttribute{
									Computed:    true,
									Description: `Flag to indicate whether automation (for adding users to entitlement based on rules) has been enabled.`,
								},
								"is_manually_managed": schema.BoolAttribute{
									Computed:    true,
									Description: `Flag to indicate if the app entitlement is manually managed.`,
								},
								"match_baton_id": schema.StringAttribute{
									Computed:    true,
									Description: `The matchBatonId field.`,
								},
								"override_access_requests_defaults": schema.BoolAttribute{
									Computed:    true,
									Description: `Flag to indicate if the app-level access request settings have been overridden for the entitlement`,
								},
								"provision_policy": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"connector_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"account_provision": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"config": schema.SingleNestedAttribute{
															Computed: true,
														},
														"connector_id": schema.StringAttribute{
															Computed:    true,
															Description: `The connectorId field.`,
														},
														"do_not_save": schema.SingleNestedAttribute{
															Computed:    true,
															Description: `The DoNotSave message.`,
														},
														"save_to_vault": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"vault_ids": schema.ListAttribute{
																	Computed:    true,
																	ElementType: types.StringType,
																	Description: `The vaultIds field.`,
																},
															},
															Description: `The SaveToVault message.`,
														},
														"schema_id": schema.StringAttribute{
															Computed:    true,
															Description: `The schemaId field.`,
														},
													},
													MarkdownDescription: `The AccountProvision message.` + "\n" +
														`` + "\n" +
														`This message contains a oneof named storage_type. Only a single field of the following list may be set at a time:` + "\n" +
														`  - saveToVault` + "\n" +
														`  - doNotSave`,
												},
												"default_behavior": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"connector_id": schema.StringAttribute{
															Computed: true,
															MarkdownDescription: `this checks if the entitlement is enabled by provisioning in a specific connector` + "\n" +
																` this can happen automatically and doesn't need any extra info`,
														},
													},
													Description: `The DefaultBehavior message.`,
												},
											},
											MarkdownDescription: `Indicates that a connector should perform the provisioning. This object has no fields.` + "\n" +
												`` + "\n" +
												`This message contains a oneof named provision_type. Only a single field of the following list may be set at a time:` + "\n" +
												`  - defaultBehavior` + "\n" +
												`  - account`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"delegated_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed:    true,
													Description: `The AppID of the entitlement to delegate provisioning to.`,
												},
												"entitlement_id": schema.StringAttribute{
													Computed:    true,
													Description: `The ID of the entitlement we are delegating provisioning to.`,
												},
											},
											Description: `This provision step indicates that we should delegate provisioning to the configuration of another app entitlement. This app entitlement does not have to be one from the same app, but MUST be configured as a proxy binding leading into this entitlement.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"external_ticket_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed:    true,
													Description: `The appId field.`,
												},
												"connector_id": schema.StringAttribute{
													Computed:    true,
													Description: `The connectorId field.`,
												},
												"external_ticket_provisioner_config_id": schema.StringAttribute{
													Computed:    true,
													Description: `The externalTicketProvisionerConfigId field.`,
												},
												"instructions": schema.StringAttribute{
													Computed:    true,
													Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
												},
											},
											Description: `This provision step indicates that we should check an external ticket to provision this entitlement`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"manual_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"instructions": schema.StringAttribute{
													Computed:    true,
													Description: `This field indicates a text body of instructions for the provisioner to indicate.`,
												},
												"user_ids": schema.ListAttribute{
													Computed:    true,
													ElementType: types.StringType,
													Description: `An array of users that are required to provision during this step.`,
												},
											},
											Description: `Manual provisioning indicates that a human must intervene for the provisioning of this step.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
											},
										},
										"multi_step": schema.StringAttribute{
											Computed:    true,
											Description: `MultiStep indicates that this provision step has multiple steps to process. Parsed as JSON.`,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("webhook_provision"),
												}...),
												validators.IsValidJSON(),
											},
										},
										"unconfigured_provision": schema.SingleNestedAttribute{
											Computed:    true,
											Description: `The UnconfiguredProvision message.`,
										},
										"webhook_provision": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"webhook_id": schema.StringAttribute{
													Computed:    true,
													Description: `The ID of the webhook to call for provisioning.`,
												},
											},
											Description: `This provision step indicates that a webhook should be called to provision this entitlement.`,
											Validators: []validator.Object{
												objectvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("connector_provision"),
													path.MatchRelative().AtParent().AtName("delegated_provision"),
													path.MatchRelative().AtParent().AtName("external_ticket_provision"),
													path.MatchRelative().AtParent().AtName("manual_provision"),
													path.MatchRelative().AtParent().AtName("multi_step"),
												}...),
											},
										},
									},
									MarkdownDescription: `ProvisionPolicy is a oneOf that indicates how a provision step should be processed.` + "\n" +
										`` + "\n" +
										`This message contains a oneof named typ. Only a single field of the following list may be set at a time:` + "\n" +
										`  - connector` + "\n" +
										`  - manual` + "\n" +
										`  - delegated` + "\n" +
										`  - webhook` + "\n" +
										`  - multiStep` + "\n" +
										`  - externalTicket` + "\n" +
										`  - unconfigured`,
								},
								"purpose": schema.StringAttribute{
									Computed:    true,
									Description: `The purpose field. must be one of ["APP_ENTITLEMENT_PURPOSE_VALUE_UNSPECIFIED", "APP_ENTITLEMENT_PURPOSE_VALUE_ASSIGNMENT", "APP_ENTITLEMENT_PURPOSE_VALUE_PERMISSION"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"APP_ENTITLEMENT_PURPOSE_VALUE_UNSPECIFIED",
											"APP_ENTITLEMENT_PURPOSE_VALUE_ASSIGNMENT",
											"APP_ENTITLEMENT_PURPOSE_VALUE_PERMISSION",
										),
									},
								},
								"revoke_policy_id": schema.StringAttribute{
									Computed:    true,
									Description: `The ID of the policy that will be used for revoke tickets related to the app entitlement`,
								},
								"risk_level_value_id": schema.StringAttribute{
									Computed:    true,
									Description: `The riskLevelValueId field.`,
								},
								"slug": schema.StringAttribute{
									Computed:    true,
									Description: `The slug is displayed as an oval next to the name in the frontend of C1, it tells you what permission the entitlement grants. See https://www.conductorone.com/docs/product/admin/entitlements/`,
								},
								"source_connector_ids": schema.MapAttribute{
									Computed:    true,
									ElementType: types.StringType,
									Description: `Map to tell us which connector the entitlement came from.`,
								},
								"system_builtin": schema.BoolAttribute{
									Computed:    true,
									Description: `This field indicates if this is a system builtin entitlement.`,
								},
								"updated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
							MarkdownDescription: `The app entitlement represents one permission in a downstream App (SAAS) that can be granted. For example, GitHub Read vs GitHub Write.` + "\n" +
								`` + "\n" +
								`This message contains a oneof named max_grant_duration. Only a single field of the following list may be set at a time:` + "\n" +
								`  - durationUnset` + "\n" +
								`  - durationGrant`,
						},
					},
				},
				Description: `The list of results containing up to X results, where X is the page size defined in the request.`,
			},
			"next_page_token": schema.StringAttribute{
				Computed: true,
				MarkdownDescription: `The nextPageToken is shown for the next page if the number of results is larger than the max page size.` + "\n" +
					` The server returns one page of results and the nextPageToken until all results are retreived.` + "\n" +
					` To retrieve the next page, use the same request and append a pageToken field with the value of nextPageToken shown on the previous page.`,
			},
		},
	}
}

func (r *AccessProfileRequestableEntriesResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.ConductoroneAPI)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.ConductoroneAPI, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *AccessProfileRequestableEntriesResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *AccessProfileRequestableEntriesResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIRequestcatalogV1RequestCatalogManagementServiceAddAppEntitlementsRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.RequestCatalogManagement.AddAppEntitlements(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.RequestCatalogManagementServiceAddAppEntitlementsResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedRequestCatalogManagementServiceAddAppEntitlementsResponse(ctx, res.RequestCatalogManagementServiceAddAppEntitlementsResponse)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsC1APIRequestcatalogV1RequestCatalogManagementServiceListEntitlementsPerCatalogRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.RequestCatalogManagement.ListEntitlementsPerCatalog(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.RequestCatalogManagementServiceListEntitlementsPerCatalogResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedRequestCatalogManagementServiceListEntitlementsPerCatalogResponse(ctx, res1.RequestCatalogManagementServiceListEntitlementsPerCatalogResponse)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AccessProfileRequestableEntriesResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *AccessProfileRequestableEntriesResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIRequestcatalogV1RequestCatalogManagementServiceListEntitlementsPerCatalogRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.RequestCatalogManagement.ListEntitlementsPerCatalog(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.RequestCatalogManagementServiceListEntitlementsPerCatalogResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedRequestCatalogManagementServiceListEntitlementsPerCatalogResponse(ctx, res.RequestCatalogManagementServiceListEntitlementsPerCatalogResponse)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AccessProfileRequestableEntriesResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *AccessProfileRequestableEntriesResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AccessProfileRequestableEntriesResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *AccessProfileRequestableEntriesResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsC1APIRequestcatalogV1RequestCatalogManagementServiceRemoveAppEntitlementsRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.RequestCatalogManagement.RemoveAppEntitlements(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *AccessProfileRequestableEntriesResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("catalog_id"), req.ID)...)
}
