// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

// The ExpressionApproval message.
type ExpressionApproval struct {
	// Configuration to allow self approval of if the user is specified and also the target of the ticket.
	AllowSelfApproval *bool `json:"allowSelfApproval,omitempty"`
	// The assignedUserIds field.
	AssignedUserIds []string `json:"assignedUserIds,omitempty"`
	// Array of dynamic expressions to determine the approvers.  The first expression to return a non-empty list of users will be used.
	Expressions []string `json:"expressions,omitempty"`
	// Configuration to allow a fallback if the expression does not return a valid list of users.
	Fallback *bool `json:"fallback,omitempty"`
	// Configuration to specific which users to fallback to if and the expression does not return a valid list of users.
	FallbackUserIds []string `json:"fallbackUserIds,omitempty"`
	// Configuration to require distinct approvers across approval steps of a rule.
	RequireDistinctApprovers *bool `json:"requireDistinctApprovers,omitempty"`
}

func (e *ExpressionApproval) GetAllowSelfApproval() *bool {
	if e == nil {
		return nil
	}
	return e.AllowSelfApproval
}

func (e *ExpressionApproval) GetAssignedUserIds() []string {
	if e == nil {
		return nil
	}
	return e.AssignedUserIds
}

func (e *ExpressionApproval) GetExpressions() []string {
	if e == nil {
		return nil
	}
	return e.Expressions
}

func (e *ExpressionApproval) GetFallback() *bool {
	if e == nil {
		return nil
	}
	return e.Fallback
}

func (e *ExpressionApproval) GetFallbackUserIds() []string {
	if e == nil {
		return nil
	}
	return e.FallbackUserIds
}

func (e *ExpressionApproval) GetRequireDistinctApprovers() *bool {
	if e == nil {
		return nil
	}
	return e.RequireDistinctApprovers
}
