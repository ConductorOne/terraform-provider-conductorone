// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// WellKnownRegex specifies a common well known pattern defined as a regex.
// This field is part of the `well_known` oneof.
// See the documentation for `validate.StringRules` for more details.
type WellKnownRegex string

const (
	WellKnownRegexUnknown         WellKnownRegex = "UNKNOWN"
	WellKnownRegexHTTPHeaderName  WellKnownRegex = "HTTP_HEADER_NAME"
	WellKnownRegexHTTPHeaderValue WellKnownRegex = "HTTP_HEADER_VALUE"
)

func (e WellKnownRegex) ToPointer() *WellKnownRegex {
	return &e
}
func (e *WellKnownRegex) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UNKNOWN":
		fallthrough
	case "HTTP_HEADER_NAME":
		fallthrough
	case "HTTP_HEADER_VALUE":
		*e = WellKnownRegex(v)
		return nil
	default:
		return fmt.Errorf("invalid value for WellKnownRegex: %v", v)
	}
}

// StringRules describe the constraints applied to `string` values
//
// This message contains a oneof named well_known. Only a single field of the following list may be set at a time:
//   - email
//   - hostname
//   - ip
//   - ipv4
//   - ipv6
//   - uri
//   - uriRef
//   - address
//   - uuid
//   - wellKnownRegex
type StringRules struct {
	// Address specifies that the field must be either a valid hostname as
	//  defined by RFC 1034 (which does not support internationalized domain
	//  names or IDNs), or it can be a valid IP (v4 or v6).
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	Address *bool `json:"address,omitempty"`
	// Const specifies that this field must be exactly the specified value
	Const *string `json:"const,omitempty"`
	// Contains specifies that this field must have the specified substring
	//  anywhere in the string.
	Contains *string `json:"contains,omitempty"`
	// Email specifies that the field must be a valid email address as
	//  defined by RFC 5322
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	Email *bool `json:"email,omitempty"`
	// Hostname specifies that the field must be a valid hostname as
	//  defined by RFC 1034. This constraint does not support
	//  internationalized domain names (IDNs).
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	Hostname *bool `json:"hostname,omitempty"`
	// IgnoreEmpty specifies that the validation rules of this field should be
	//  evaluated only if the field is not empty
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty"`
	// In specifies that this field must be equal to one of the specified
	//  values
	In []string `json:"in,omitempty"`
	// Ip specifies that the field must be a valid IP (v4 or v6) address.
	//  Valid IPv6 addresses should not include surrounding square brackets.
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	IP *bool `json:"ip,omitempty"`
	// Ipv4 specifies that the field must be a valid IPv4 address.
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	Ipv4 *bool `json:"ipv4,omitempty"`
	// Ipv6 specifies that the field must be a valid IPv6 address. Valid
	//  IPv6 addresses should not include surrounding square brackets.
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	Ipv6 *bool `json:"ipv6,omitempty"`
	// Len specifies that this field must be the specified number of
	//  characters (Unicode code points). Note that the number of
	//  characters may differ from the number of bytes in the string.
	Length *string `json:"len,omitempty"`
	// LenBytes specifies that this field must be the specified number of bytes
	//  at a minimum
	LenBytes *string `json:"lenBytes,omitempty"`
	// MaxBytes specifies that this field must be the specified number of bytes
	//  at a maximum
	MaxBytes *string `json:"maxBytes,omitempty"`
	// MaxLen specifies that this field must be the specified number of
	//  characters (Unicode code points) at a maximum. Note that the number of
	//  characters may differ from the number of bytes in the string.
	MaxLen *string `json:"maxLen,omitempty"`
	// MinBytes specifies that this field must be the specified number of bytes
	//  at a minimum
	MinBytes *string `json:"minBytes,omitempty"`
	// MinLen specifies that this field must be the specified number of
	//  characters (Unicode code points) at a minimum. Note that the number of
	//  characters may differ from the number of bytes in the string.
	MinLen *string `json:"minLen,omitempty"`
	// NotContains specifies that this field cannot have the specified substring
	//  anywhere in the string.
	NotContains *string `json:"notContains,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	//  values
	NotIn []string `json:"notIn,omitempty"`
	// Pattern specifes that this field must match against the specified
	//  regular expression (RE2 syntax). The included expression should elide
	//  any delimiters.
	Pattern *string `json:"pattern,omitempty"`
	// Prefix specifies that this field must have the specified substring at
	//  the beginning of the string.
	Prefix *string `json:"prefix,omitempty"`
	// This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
	//  strict header validation.
	//  By default, this is true, and HTTP header validations are RFC-compliant.
	//  Setting to false will enable a looser validations that only disallows
	//  \r\n\0 characters, which can be used to bypass header matching rules.
	Strict *bool `json:"strict,omitempty"`
	// Suffix specifies that this field must have the specified substring at
	//  the end of the string.
	Suffix *string `json:"suffix,omitempty"`
	// Uri specifies that the field must be a valid, absolute URI as defined
	//  by RFC 3986
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	URI *bool `json:"uri,omitempty"`
	// UriRef specifies that the field must be a valid URI as defined by RFC
	//  3986 and may be relative or absolute.
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	URIRef *bool `json:"uriRef,omitempty"`
	// Uuid specifies that the field must be a valid UUID as defined by
	//  RFC 4122
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	UUID *bool `json:"uuid,omitempty"`
	// WellKnownRegex specifies a common well known pattern defined as a regex.
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.StringRules` for more details.
	WellKnownRegex *WellKnownRegex `json:"wellKnownRegex,omitempty"`
}

func (s *StringRules) GetAddress() *bool {
	if s == nil {
		return nil
	}
	return s.Address
}

func (s *StringRules) GetConst() *string {
	if s == nil {
		return nil
	}
	return s.Const
}

func (s *StringRules) GetContains() *string {
	if s == nil {
		return nil
	}
	return s.Contains
}

func (s *StringRules) GetEmail() *bool {
	if s == nil {
		return nil
	}
	return s.Email
}

func (s *StringRules) GetHostname() *bool {
	if s == nil {
		return nil
	}
	return s.Hostname
}

func (s *StringRules) GetIgnoreEmpty() *bool {
	if s == nil {
		return nil
	}
	return s.IgnoreEmpty
}

func (s *StringRules) GetIn() []string {
	if s == nil {
		return nil
	}
	return s.In
}

func (s *StringRules) GetIP() *bool {
	if s == nil {
		return nil
	}
	return s.IP
}

func (s *StringRules) GetIpv4() *bool {
	if s == nil {
		return nil
	}
	return s.Ipv4
}

func (s *StringRules) GetIpv6() *bool {
	if s == nil {
		return nil
	}
	return s.Ipv6
}

func (s *StringRules) GetLength() *string {
	if s == nil {
		return nil
	}
	return s.Length
}

func (s *StringRules) GetLenBytes() *string {
	if s == nil {
		return nil
	}
	return s.LenBytes
}

func (s *StringRules) GetMaxBytes() *string {
	if s == nil {
		return nil
	}
	return s.MaxBytes
}

func (s *StringRules) GetMaxLen() *string {
	if s == nil {
		return nil
	}
	return s.MaxLen
}

func (s *StringRules) GetMinBytes() *string {
	if s == nil {
		return nil
	}
	return s.MinBytes
}

func (s *StringRules) GetMinLen() *string {
	if s == nil {
		return nil
	}
	return s.MinLen
}

func (s *StringRules) GetNotContains() *string {
	if s == nil {
		return nil
	}
	return s.NotContains
}

func (s *StringRules) GetNotIn() []string {
	if s == nil {
		return nil
	}
	return s.NotIn
}

func (s *StringRules) GetPattern() *string {
	if s == nil {
		return nil
	}
	return s.Pattern
}

func (s *StringRules) GetPrefix() *string {
	if s == nil {
		return nil
	}
	return s.Prefix
}

func (s *StringRules) GetStrict() *bool {
	if s == nil {
		return nil
	}
	return s.Strict
}

func (s *StringRules) GetSuffix() *string {
	if s == nil {
		return nil
	}
	return s.Suffix
}

func (s *StringRules) GetURI() *bool {
	if s == nil {
		return nil
	}
	return s.URI
}

func (s *StringRules) GetURIRef() *bool {
	if s == nil {
		return nil
	}
	return s.URIRef
}

func (s *StringRules) GetUUID() *bool {
	if s == nil {
		return nil
	}
	return s.UUID
}

func (s *StringRules) GetWellKnownRegex() *WellKnownRegex {
	if s == nil {
		return nil
	}
	return s.WellKnownRegex
}
