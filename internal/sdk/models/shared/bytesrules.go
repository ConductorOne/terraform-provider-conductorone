// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

// BytesRules describe the constraints applied to `bytes` values
//
// This message contains a oneof named well_known. Only a single field of the following list may be set at a time:
//   - ip
//   - ipv4
//   - ipv6
type BytesRules struct {
	// Const specifies that this field must be exactly the specified value
	Const *string `json:"const,omitempty"`
	// Contains specifies that this field must have the specified bytes
	//  anywhere in the string.
	Contains *string `json:"contains,omitempty"`
	// IgnoreEmpty specifies that the validation rules of this field should be
	//  evaluated only if the field is not empty
	IgnoreEmpty *bool `json:"ignoreEmpty,omitempty"`
	// In specifies that this field must be equal to one of the specified
	//  values
	In []string `json:"in,omitempty"`
	// Ip specifies that the field must be a valid IP (v4 or v6) address in
	//  byte format
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.BytesRules` for more details.
	IP *bool `json:"ip,omitempty"`
	// Ipv4 specifies that the field must be a valid IPv4 address in byte
	//  format
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.BytesRules` for more details.
	Ipv4 *bool `json:"ipv4,omitempty"`
	// Ipv6 specifies that the field must be a valid IPv6 address in byte
	//  format
	// This field is part of the `well_known` oneof.
	// See the documentation for `validate.BytesRules` for more details.
	Ipv6 *bool `json:"ipv6,omitempty"`
	// Len specifies that this field must be the specified number of bytes
	Len *string `json:"len,omitempty"`
	// MaxLen specifies that this field must be the specified number of bytes
	//  at a maximum
	MaxLen *string `json:"maxLen,omitempty"`
	// MinLen specifies that this field must be the specified number of bytes
	//  at a minimum
	MinLen *string `json:"minLen,omitempty"`
	// NotIn specifies that this field cannot be equal to one of the specified
	//  values
	NotIn []string `json:"notIn,omitempty"`
	// Pattern specifes that this field must match against the specified
	//  regular expression (RE2 syntax). The included expression should elide
	//  any delimiters.
	Pattern *string `json:"pattern,omitempty"`
	// Prefix specifies that this field must have the specified bytes at the
	//  beginning of the string.
	Prefix *string `json:"prefix,omitempty"`
	// Suffix specifies that this field must have the specified bytes at the
	//  end of the string.
	Suffix *string `json:"suffix,omitempty"`
}

func (o *BytesRules) GetConst() *string {
	if o == nil {
		return nil
	}
	return o.Const
}

func (o *BytesRules) GetContains() *string {
	if o == nil {
		return nil
	}
	return o.Contains
}

func (o *BytesRules) GetIgnoreEmpty() *bool {
	if o == nil {
		return nil
	}
	return o.IgnoreEmpty
}

func (o *BytesRules) GetIn() []string {
	if o == nil {
		return nil
	}
	return o.In
}

func (o *BytesRules) GetIP() *bool {
	if o == nil {
		return nil
	}
	return o.IP
}

func (o *BytesRules) GetIpv4() *bool {
	if o == nil {
		return nil
	}
	return o.Ipv4
}

func (o *BytesRules) GetIpv6() *bool {
	if o == nil {
		return nil
	}
	return o.Ipv6
}

func (o *BytesRules) GetLen() *string {
	if o == nil {
		return nil
	}
	return o.Len
}

func (o *BytesRules) GetMaxLen() *string {
	if o == nil {
		return nil
	}
	return o.MaxLen
}

func (o *BytesRules) GetMinLen() *string {
	if o == nil {
		return nil
	}
	return o.MinLen
}

func (o *BytesRules) GetNotIn() []string {
	if o == nil {
		return nil
	}
	return o.NotIn
}

func (o *BytesRules) GetPattern() *string {
	if o == nil {
		return nil
	}
	return o.Pattern
}

func (o *BytesRules) GetPrefix() *string {
	if o == nil {
		return nil
	}
	return o.Prefix
}

func (o *BytesRules) GetSuffix() *string {
	if o == nil {
		return nil
	}
	return o.Suffix
}
